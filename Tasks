{- #1 Безпечне отримання першого елемента
Напишіть функцію safeHead, яка повертає перший елемент
списку або Nothing, якщо список порожній.
-}
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

{- #2 Безпечне ділення
Напишіть функцію safeDiv, яка виконує ділення
з перевіркою ділення на нуль.
-}
safeDiv :: (Eq a, Fractional a) => a -> a -> Maybe a
safeDiv _ 0 = Nothing
safeDiv x y = Just (x/y)

{- #3 Побудова множника
Напишіть функцію mkMultiplier, яка приймає число
і повертає функцію множення на це число.
-}
mkMultiplier :: Num a => a -> (a -> a)
mkMultiplier n = (\x -> n * x)

{- #4 Застосування функції двічі
Напишіть функцію applyTwice, яка приймає 
функцію та значення, і застосовує функцію двічі.
-}
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f(f x)

{- #5 Власна реалізація map
Реалізуйте свою версію функції map під назвою myMap.
-}
myMap :: (a -> b) -> [a] -> [b]
myMap _ [] = []
myMap f (x:xs) = f x : myMap f xs

{- #6 Фільтрація за предикатом
Реалізуйте свою версію filter під назвою myFilter.
-}
myFilter :: (a -> Bool) -> [a] -> [a]
myFilter _ [] = []
myFilter p (x:xs)
  | p x = x : myFilter p xs
  | otherwise = myFilter p xs

{- #7 Обчислення середнього значення
Реалізуйте функцію avg, яка обчислює середнє значення списку. 
Якщо список порожній, повертає Nothing.
-}
avg :: (Fractional a) => [a] -> Maybe a
avg [] = Nothing
avg xs = Just(sum xs / fromIntegral(length xs))

{- #8 Композиція перетворень
Створіть функцію processList, яка:
1. Залишає лише непарні числа;
2. Підносить до квадрату;
3. Повертає перші 3 елементи.
-}
processList :: [Int] -> [Int]
processList = take 3 . map(^2) . filter odd

{- 9 Пошук елемента в списку
Напишіть функцію findIndex, яка повертає індекс
першого входження елемента в списку, або Nothing, якщо
елемент не знайдено.
-}
findIndex :: Eq a => a -> [a] -> Maybe Int
findIndex target = go 0
 where
  go _ [] = Nothing
  go i (x:xs)
   | x == target = Just i
   |otherwise = go (i+1) xs

{- #10 Узагальнене застосування списку функцій
Напишіть функцію applyAll, яка приймає список функцій
та одне значення, і послідовно застосовує всі функції до
цього значення.
-}
applyAll :: [a -> a] -> a -> a
applyAll fs x = foldl(\acc f -> f acc) x fs

{- #11 Бінарний пошук
Реалізуйте рекурсивну функцію binarySearch, яка приймає
відсортований список і значення, що потрібно знайти, та
повертає індекс знайденого елемента або Nothing, якщо такого немає.
-}
binarySearch :: Ord a => [a] -> a -> Maybe Int
binarySearch xs target = go 0 (length xs - 1)
 where
  go low high
    | low > high = Nothing
    | otherwise =
      let mid = (low + high) `div` 2
          val = xs !! mid
      in if val == target
          then Just mid
          else if val < target
               then go(mid+1) high
               else go low(mid-1)

{-Реалізуйте рекурсивну функцію quickSort,
яка сортує список за зростанням.
-}
quickSort :: Ord a => [a] -> [a]
quickSort [] = []
quickSort(x:xs) = 
  let smaller = quickSort [y| y <- xs, y <= x]
      bigger = quickSort [y| y <- xs, x > y]
  in smaller ++ [x] ++ bigger

{-Реалізуйте рекурсивну функцію hanoi,
яка моделює розв’язання класичної задачі про
переміщення n дисків з одного стрижня на інший за
допомогою третього.-}
type Peg = String
type Move = (Peg, Peg)

hanoi :: Int -> Peg -> Peg -> Peg -> [Move]
hanoi 0 _ _ _ = []
hanoi n from to aux = 
  hanoi (n-1) from aux to ++
  [(from, to)] ++
  hanoi (n-1) aux to from

main :: IO ()
main = do
  putStrLn "=== Завдання 1: safeHead ==="
  print (safeHead [10,20,30])  -- Just 10
  print (safeHead ([] :: [Int])) -- Nothing

  putStrLn "\n=== Завдання 2: safeDiv ==="
  print (safeDiv 10 2)  -- Just 5.0
  print (safeDiv 7 0)   -- Nothing

  putStrLn "\n=== Завдання 3: mkMultiplier ==="
  let double = mkMultiplier 2
  let triple = mkMultiplier 3
  print (double 5)  -- 10
  print (triple 4)  -- 12

  putStrLn "\n=== Завдання 4: applyTwice ==="
  print (applyTwice (+1) 3)  -- 5
  print (applyTwice (*2) 4)  -- 16

  putStrLn "\n=== Завдання 5: myMap ==="
  print (myMap (*2) [1,2,3])     -- [2,4,6]
  print (myMap show [1,2,3])     -- ["1","2","3"]

  putStrLn "\n=== Завдання 6: myFilter ==="
  print (myFilter even [1..10])  -- [2,4,6,8,10]
  print (myFilter (>3) [1,2,3,4,5]) -- [4,5]

  putStrLn "\n=== Завдання 7: avg ==="
  print (avg [1,2,3,4])  -- Just 2.5
  print (avg ([] :: [Double]))  -- Nothing

  putStrLn "\n=== Завдання 8: processList ==="
  print (processList [1..10])   -- [1,9,25]
  print (processList [2,4,6])   -- []

  putStrLn "\n=== Завдання 9: findIndex ==="
  print (findIndex 3 [1,2,3,4]) -- Just 2
  print (findIndex 9 [1,2,3])   -- Nothing

  putStrLn "\n=== Завдання 10: applyAll ==="
  print (applyAll [(*2), (+1), (^2)] 3) -- 49
  print (applyAll [negate, abs] (-5))   -- 5

  putStrLn "\n=== Завдання 11: binarySearch ==="
  print (binarySearch [1,3,5,7,9] 5) -- Just 2
  print (binarySearch [1,3,5,7,9] 4) -- Nothing

  putStrLn "\n=== Завдання 12: quickSort ==="
  print (quickSort [3,1,4,1,5,9,2]) -- [1,1,2,3,4,5,9]

  putStrLn "\n=== Завдання 13: hanoi ==="
  print (hanoi 2 "A" "C" "B")
  print (hanoi 3 "L" "R" "M")













